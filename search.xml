<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自用快速手册]]></title>
    <url>%2F2020%2F05%2F08%2F%E8%87%AA%E7%94%A8%E5%BF%AB%E9%80%9F%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[不知道干啥时的快速便签 Git想要从原仓库将更新的commit更新到本地的场合比如想将更新merge到master主分支上, 那么首先保证我们在主分支上: 看看我们在哪个分支上git branch 切回主分支git checkout master 接下来先将远端的代码先载到本地git fetch upstream_pcp(以我自己的pcp项目为例, 最后这个远程仓库名可通过git remote -v查看) 此时可能会出现需要手动merge代码的情况, 我用vsCode所以在source control里可以可视化地merge代码. merge完毕之后需要commit一下, 并在文件里描述这次merge. 好, 完成以上操作后可以进行merge了git merge upstream_pcp/master 此时便将fetch的代码,以及我们手动merge的代码merge进当前的branch. 撤销commit只是撤销commit而已哦git reset --soft HEAD~1 编译动态库动态库编译install后, 可能由于缓存没有更新导致程序还在使用旧的库. 此时ldconfig GDB自己编译的时候使用gcc -g xxx.c, -g会创建符号表/关闭优化(诶大丈夫?)程序将按照代码来执行. 对于需要args参数的程序调试示例gdb --args pmseries &#39;kernel.all.load[count:5]&#39; 打开gdb后, 使用layout next来看代码. 使用break function_name来对某个函数设定断点 运行run开始运行程序 使用next或step来使程序进入下一步, 区别在于next不会进入函数,而step在执行函数时会跳到那个函数内部. 使用print xx来打印想看的变量 有时会出现“Cannot find bounds of current function”提示, 这时候适当地使用ni [number] number大小实操来取吧, 好像这个是调libuv库的时候会发生的事情. 有时画面会一团糟, 使用refresh set print pretty on/off(默认) 是否以换行缩进的方式打印结构体，或者类。 PCP 有时pmlogger会自己消失, 为啥呢? 难道pmlogger有自己的生命期, 时间一到就kill自己? 似乎只有在pmproxy, pmlogger同时运行时才能使用pmseries查询time series, 每个metric的采集时间不一样. 而且似乎并不是pmlogger一开启pmproxy就进行转发到redis. 因此启动后若使用pmseries没有反应请耐心等待个几分钟. log文件储存在/var/log/pcp/下各文件夹中 一些启动脚本在/etc/init.d/中 ./pmcd stop不了的时候试试./pcp stop 使用redis-cli直接向redis查询, 根据series identifier来查询value的语句参考XRANGE pcp:values:series:7d0a5094fa4ffe7aecfa4287ca25855b0c34816f - + count 2 Notebook 在remote host上启动notebook后, 本地使用ssh -N -f -L 127.0.0.1:25252:127.0.0.1:25252 username@ip_address来使本地与远端建立连接 pip ERROR: Could not install packages due to an EnvironmentError: [Errno 28] No space left on device. 此时修改一下temp文件夹目录, 使用export TMPDIR=~/zys/temp/ 换源install使用pip install torchvision -i https://mirrors.nju.edu.cn/pypi/web/simple DNS 修改/etc/resolv.conf 内的nameserver 8.8.8.8]]></content>
  </entry>
  <entry>
    <title><![CDATA[Google Summer of Code: Timeseries query language extension for PCP]]></title>
    <url>%2F2020%2F05%2F08%2FGoogle-Summer-of-Code-Timeseries-query-language-extension-for-PCP%2F</url>
    <content type="text"><![CDATA[This blog is just a simple note for the project Timeseries query language extension during this summer. GrammarThe grammar description file is located on src/libpcp_web/src/query_parser.y. It’s a yacc file. Existing related grammar$query\to vector$ Extended grammar $vector\to func\{exprlist\}[timelist]$ $vector\to func[timelist]$ $func\to {\bf rate}(name)$ StatusStoring time series values into paser tree’s nodesGit branch link In src/libpcp_web/src/query.c new functions: static int series_process_func(seriesQueryBaton *baton, node_t *np, int level): Called by series_query_report_values, process funtion-type nodes in this function. Traverse the parser tree and once a node is an function-type node and its children nodes need to query to Redis to gather actual series values, do querying and store the values into the corresponding children node. static void series_node_prepare_time(seriesQueryBaton *baton, series_set_t *query_series_set, node_t *np): Called by series_process_func when a child of a function-type node need to query to Redis. For each series-id stored in the child node, first store the SID into this node’s value_set.SID, then query to Redis with every SID together with a timewindow. static void series_node_prepare_time_reply(redisAsyncContext *c, redisReply *reply, const sds cmd, void *arg): Called by series_node_prepare_time. After Redis giving back a reply to a specific SID with a timewindow, count how many sample are in this reply. Check if this reply is correct and call series_values_store_to_node to store these samples into the correspoding node. Then update np-&gt;value_set.num_series, this variable is to record how many series’ values have been stored for this node. static void series_values_store_to_node(seriesQueryBaton *baton, sds series, int nsamples, redisReply **samples, void *arg, node_t *np): Called by series_node_prepare_time_reply. Check through a specific series’ samples replied from Redis and extract the instances’ values then call series_instance_store_to_node to store the instances’ values into these node. This function is roughly same as series_values_reply. static int series_instance_store_to_node(seriesQueryBaton *baton, sds series, pmSeriesValue *value, int nelements, redisReply **elements, node_t *np, int idx_sample): Called by series_values_store_to_node. The instance’ value store in the variable value. Store this value into np-&gt;value_set.series_values.Changes in data structuresIn src/libpcp_web/src/query.h Add a new structure struct series_value_set in order to store time series values. And add this struct into struct node. Some notes series_solve in query.c: An overview of the phases of processing a time series query statement. Bugs Run gdb --args pmseries &#39;rate(kernel.all.load)[count:2]&#39;, we can see error occurs during calling void freeReplyObject(void *r). Seems that I free a Redies reply twice. (But where?) Issues Sometime the daemon pmlogger will be killed by unknown reason. Or each pmlogger has a life period?]]></content>
  </entry>
  <entry>
    <title><![CDATA[Compiler for language tiger]]></title>
    <url>%2F2020%2F02%2F27%2FCompiler-for-language-tiger%2F</url>
    <content type="text"><![CDATA[编译日记]]></content>
  </entry>
  <entry>
    <title><![CDATA[Solutions of Google's Coding Competitions]]></title>
    <url>%2F2019%2F10%2F04%2FSoulutions-Code-Jam-to-I-O-for-Women%2F</url>
    <content type="text"><![CDATA[待补完 Kick Start2019 round GBook Reading (瞎搞)题意: 一本书有N页, 其中$P_1, P_2,…,P_M(P_i\leq N)$页都损毁了. 有$Q$个人来读它, 第$i$个人自带属性$R_i$,每个人读这本书时只会读$R_i$倍数且没有损毁的页码. 现在统计这本书一共被读了多少次(看一页算一次).$1\leq M,N, Q\leq1e5$分析:如果书没有页码损毁,答案是$\sum_{i=1}^{N}N/R_i$. 接着扣去这Q个人没读损毁的部分, 先把Q个人不读的倍数$R_i$排序(为了看有几个人$R_i$是相同的, 相同的$R_i$只做一次计算,此时最糟糕的输入数据应该是$\{R_i\}=\{1,2,…,1e5\}$,算一下复杂度大概是$\sum_{i=1}^{N}\frac{N}{i}&lt;\int_{1}^{N}\frac{1}{x-1}dx\approx\ln\frac{N}{2}$), 查看$R_i$的倍数是否损毁, 损毁则扣去. code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1e5+10;int prime[maxn];int P[maxn], R[maxn];bool torn[maxn];int main()&#123; int n, m, q; int T; //int pn = init_prime(); scanf("%d", &amp;T); int rnd = 1; while(T--)&#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); memset(torn, 0, sizeof(torn)); for(int i=0; i&lt;m; i++)&#123; scanf("%d", &amp;P[i]); torn[P[i]] = true; &#125; long long ans = 0; for(int i=0; i&lt;q; i++)&#123; scanf("%d", &amp;R[i]); ans += (n/R[i]); &#125; sort(R, R+q); int *s=R, *e=R; while(s!=R+q)&#123; e = upper_bound(R, R+q, *s); int num = e-s; for(int i=1; i*(*s)&lt;=n; i++)&#123; if(torn[i*(*s)])&#123; ans -= num; &#125; &#125; s = e; &#125; printf("Case #%d: %lld\n", rnd++, ans); &#125; return 0;&#125; The Equation(贪心, 位运算)题意:Given a non-negative integer $M$ and $N$ non-negative integers $\{A_i\}$, find the largest integer $k$ s.t. $\sum_{i=1}^{N}(A_ixork)\leq M$.分析:先把给的$M$和$N$个数都转成2进制, 一位一位地来构造$k. k$的位数一定不超过$M$和$N$个数字的最大位数. 显然要从高位开始填, 而且贪心地尽量往高位填1.先把$k$的每一位填0或者1, 得到该位的异或和算出来. 接下来用一个数组minSum$[i]$来记录到第$i-1$位为止, 能取到的最小异或和的和(每一位异或和,再把这$i-1$个异或和加起来).搞完这些就可以开始贪心填1惹, 试一试第$i$位填1得到的异或和$+minSum[i]$会不会超出$M$即可. Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;using namespace std;const int maxn = 1010;long long A, m, minSum[maxn], bit1[maxn], bit0[maxn];int two[maxn][55], res2[55];int maxx;void decode(int index, long long n)&#123; int temp[55]; int k = 0; while(n)&#123; temp[k++] = n%2; n /= 2; &#125; int p = 0; maxx = max(k, maxx); for(int i=0; i&lt;k; i++)&#123; two[index][p++] = temp[i]; &#125;&#125;long long two2ll(int* a, int n)&#123; long long res = 0, p = 1; for(int i=0; i&lt;=maxx; i++)&#123; res += a[i]*p; p *= 2; &#125; return res;&#125;int main()&#123; int rnd=1, T, n; scanf("%d", &amp;T); while(T--)&#123; maxx = 0; memset(two, 0, sizeof(two)); scanf("%d%lld", &amp;n, &amp;m); for(int i=0; i&lt;n; i++)&#123; scanf("%lld", &amp;A); decode(i, A); &#125; decode(n, m); minSum[0] = 0; for(int j=0; j&lt;=maxx; j++)&#123; long long now1=0, now0 = 0; for(int i=0; i&lt;n; i++)&#123; now1 += (two[i][j]^1); now0 += (two[i][j]^0); &#125; bit1[j] = now1*pow(2, j); bit0[j] = now0*pow(2, j); minSum[j+1] = minSum[j]+min(bit1[j], bit0[j]); &#125; for(int i=maxx; i&gt;=0; i--)&#123; if(m-bit1[i] &gt;= minSum[i])&#123; res2[i] = 1; m -= bit1[i]; &#125;else&#123; res2[i] = 0; m -= bit0[i]; &#125; &#125; printf("Case #%d: %lld\n", rnd++, m&gt;=0?two2ll(res2, maxx):-1); &#125; return 0;&#125; Shifts(状压dp, 位运算)题意:两保安要排n天的班, 这两个保安a,b在第$i$天如果上班的话会分别收获$A[i],B[i]$快乐值. 每一天至少要有一个人上班. 最后两人的快乐值总和应不小于$h$. 问有多少排班方案.$0\leq N\leq 20$分析:暴搜的话$3^{20}\approx3.5\times1e9$,不太行. 使用$[0,2^n-1]$之间的整数来表示A的排班表, 第n位为0表示不上班, 1表示上班. 用$f[i]$表示, 在A的排班表为$i$时, 能够使B的快乐达到$h$的方案数.先计算一天只有一个人上班的情况, 枚举$2^n$种A的排班方案$\{i\}$. 由于只有一个人上班,所以$i$的二进制某位为1时,A上班B不上班. 把这$2^n$种排版方案中使B的快乐值达到h的方案挑出来, 即令$f[i]=1$;接下来把A,B都上班的情况算进去. 某天A不上班, 比如9=1001的第二天,默认B的排班不变, 这个状态下的方案数应该贡献到13=1101的方案数中去. 即$(A,B)=(1101, 0110)\leftarrow(1001, 0110)$, 因为如果对B来说0110能使他快乐达到h,那么A在第二天上不上班无所谓.最后对$2^n$排班确认此时A的快乐值是否会达到h, 若达到则将该状态下的方案数加到答案里. 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1e7+10;long long A[30], B[30], f[maxn];int main()&#123; int T, rnd=1, n; long long h; scanf("%d", &amp;T); while(T--)&#123; scanf("%d%lld", &amp;n, &amp;h); for(int i=0; i&lt;n; i++)&#123; scanf("%lld", A+i); &#125; for(int i=0; i&lt;n; i++)&#123; scanf("%lld", B+i); &#125; int up = 1&lt;&lt;n; memset(f, 0, sizeof(f)); for(int i=0; i&lt;up; i++)&#123; long long sumB = 0; int now = 1; //assume that there are only one guy works per day. //when the bit is 1, A works, then B does not work //get all plans where sumB can reach h for(int j=0; j&lt;n; j++)&#123; if(!(i&amp;now)) sumB += B[j]; now = now&lt;&lt;1; &#125; if(sumB&gt;=h)&#123; f[i]++; &#125; &#125; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;up; j++)&#123; if(j&amp;(1&lt;&lt;i))&#123;//if A works today f[j] += f[j^(1&lt;&lt;i)]; //plans should add plans where if today does not work //0xor0/1 does not make changes, 1xor1 makes 1 turn to 0 &#125; &#125; &#125; long long ans = 0; for(int i=0; i&lt;up; i++)&#123; long long sumA = 0; int now = 1; for(int j=0; j&lt;n; j++)&#123; if(i&amp;now) sumA += A[j]; now = now&lt;&lt;1; &#125; if(sumA&gt;=h)&#123; ans += f[i]; &#125; &#125; printf("Case #%d: %lld\n", rnd++, ans); &#125; return 0;&#125; Code JamCode Jam to I/O for Women2020Interleaved Output: Part 1(贪心)贪就对了 代码: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn = 110;char str[maxn];int main()&#123; int t, rnd=1; scanf("%d", &amp;t); while(t--)&#123; int i=0, I=0, o=0, O=0; scanf("%s", str); int len = strlen(str), ans = 0; for(int k=0; k&lt;len; k++)&#123; if(str[k] == 'I') I++; else if(str[k] == 'i') i++; else if(str[k] == 'O' )&#123; if(I)&#123; --I; ans++; &#125;else&#123; --i; &#125; &#125;else if(str[k] == 'o')&#123; if(i)&#123; --i; &#125;else&#123; --I; &#125; &#125; &#125; printf("Case #%d: %d\n", rnd++, ans); &#125; return 0;&#125; Imbalance Obviation(图染色graph coloring, 图遍历)题意:We have a balance scale and $N$ identical 1-gram marbles numbered from $1$ to $N$. If the difference of the weight between the left pan and the right pan is more than 1, the scale will lose its balance. Now we play a game, we put marbles into the scale in order from $1$ to $N$, each time we put a marble, we can choose whether left or right pan to put into. After we put all marbles into the scale, we start to take them from it: the problem’s input will be a permutation of $\{1,2,…,N\}=\{A_1,A_2,…,A_N\}$, which means the number order of marbles we take out of the scale. Now we need to determine a method to put marbles into the scales(for the number $i$-th marble, choose left or right pan to put). The scale should never lose its balance during the processing above.The permutation of taking out is always legal.$1\leq N\leq 1000$分析:Divide this problem into 2 situations: $N$ is odd or even.The easier case is when $N$ is even. When we start to put marbles, we must put a marble on one side then put the next mable on the other side to keep the balance, which means for a odd-numered marble $2i-1$, it must be in a different side of $2i$‘s. For example we can put 1 in left then must put 2 in right. Then we can choose either side to put 3, say right, then we must put 4 in left.Then consider taking out, we can know after putting on, the number of left pan must equal to the right pan’s. So $A_1$ and $A_2$ must in different sides and so do $A_{2i-1}$ and ${A_{2i}}$. 可恶英文写得好麻烦所以这里面可以得到$N$个对立个关系,我们由此建一张图, 图中的点为石头的编号, 两点连边的则表示两石头不在同一盘子上. 接下来对图染色, 染两个颜色表示放左盘/右盘. 由于题目输入保证合法因此只要遍历一遍图即可染色.若$N$为基数, 我们知道放石头的时候, 第$N$个放的盘肯定比另一边多一. 取走时, 第一个取走的石子必须从多的那个盘子上取走, 即$N$和$A_1$在同一个盘上. 把这和这两者不在同一盘子内的石子添加到对方边里即可. 剩下的工作和偶数没区别,染色就vans了. 特判一下$N=A_1$的情况, 爱放哪放哪. 这题解写得我好暴躁 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1010;int save[maxn];vector&lt;int&gt; mp[maxn];int color[maxn];void init(int n)&#123; for(int i=1; i&lt;=n; i++)&#123; mp[i].clear(); &#125; memset(color, 0, sizeof(color));&#125;void dfs(int index, int flag)&#123; color[index] = flag; for(int i=0; i&lt;mp[index].size(); i++)&#123; if(color[mp[index][i]]==0)&#123;//not been visited dfs(mp[index][i], -flag); &#125; &#125;&#125;int main()&#123; int t, rnd=1; scanf("%d", &amp;t); while(t--)&#123; int n; scanf("%d", &amp;n); init(n); bool flag = false; for(int i=1; i&lt;=n; i++)&#123; scanf("%d", &amp;save[i]); if(n%2 &amp;&amp; i==1) continue; if(flag)&#123; mp[save[i]].push_back(save[i-1]); mp[save[i-1]].push_back(save[i]); &#125; flag = ! flag; &#125; for(int i=1; i&lt;=n; i++)&#123; if(i%2==0)&#123; mp[i].push_back(i-1); mp[i-1].push_back(i); &#125; &#125; if(n%2 &amp;&amp; save[1]!=n)&#123; for(int i=0; i&lt;mp[n].size(); i++)&#123; mp[save[1]].push_back(mp[n][i]); &#125; for(int i=0; i&lt;mp[save[1]].size(); i++)&#123; mp[n].push_back(mp[save[1]][i]); &#125; &#125; for(int i=1; i&lt;=n; i++)&#123; if(color[i]==0) dfs(i, 1); &#125; printf("Case #%d: ", rnd++); for(int i=1; i&lt;n; i++)&#123; if(color[i] == 1)&#123; printf("L"); &#125;else&#123; printf("R"); &#125; &#125; if(n%2 &amp;&amp; (color[save[1]]==0 &amp;&amp; color[n]==0) )&#123; printf("L"); &#125;else&#123; if(color[n] == 1)&#123; printf("L"); &#125;else&#123; printf("R"); &#125; &#125; printf("\n"); &#125; return 0;&#125; Interleaved Output: Part 2题意:There are 4 printer work independently and print “IO,Io,iO,io” respectively. 然鹅四台打印机的结果混在了一起, 像这样:index: 1 2 3 4 5 6 7 8 IO: . . . . . I . O Io: I . . . o . . . iO: . i O . . . . . io: . . . i . . o . string: I i O i o I o O现在我们拿到的是最终混在一起的打印结果, 需要猜IO这台打印机最多打了多少个IO.分析:把四台一起工作的过程看成一个NFA, 不记打印机打了几次的话, 每台打印机要么就是处于打完两个字母(准备打下一个字母)的状态0, 要么就处于打完第一个字母的状态1, 这个nfa就有2^4=16种状态. 一开始四台打印机(IO,Io,iO,io)处在0=0000, 接受一个I时转移到1100=3(左低右高). 在状态转移时再带一个额外的数字k, 记录当前打了多少个IO.最后由于只有一个终态0000, 把在此状态下的k取最大值即可 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int maxn = 110;char str[maxn];queue&lt; pair&lt;int, int&gt; &gt; que[2];//first-&gt;which state, second-&gt;number of IO matchedmap&lt; pair&lt;int,int&gt;, bool&gt;mp;void init()&#123; while(!que[0].empty())&#123; que[0].pop(); &#125; while(!que[1].empty())&#123; que[1].pop(); &#125; mp.clear();&#125;int main()&#123; int t, rnd=1; scanf("%d", &amp;t); while(t--)&#123; scanf("%s", str); int ans = 0, len=strlen(str); init(); bool flag = false; que[flag].push(make_pair(0, 0)); for(int i=0; i&lt;len; i++)&#123; char now = str[i]; mp.clear(); while(!que[flag].empty())&#123; pair&lt;int, int&gt; q = que[flag].front(), temp; que[flag].pop(); if(now=='I')&#123; if( (q.first&amp;(1&lt;&lt;0)) == 0)&#123;//machine IO not print yet temp = make_pair(q.first+1, q.second); if(!mp[temp])&#123; que[!flag].push(temp); mp[temp] = true; &#125; &#125; if( (q.first&amp;(1&lt;&lt;1)) == 0)&#123;//machine Io not print yet temp = make_pair(q.first+2, q.second); if(!mp[temp])&#123; que[!flag].push(temp); mp[temp] = true; &#125; &#125; &#125;else if(now == 'i')&#123; if( (q.first&amp;(1&lt;&lt;2)) == 0)&#123;//machine iO not print yet temp = make_pair(q.first+4, q.second); if(!mp[temp])&#123; que[!flag].push(temp); mp[temp] = true; &#125; &#125; if( (q.first&amp;(1&lt;&lt;3)) == 0)&#123;//machine io not print yet temp = make_pair(q.first+8, q.second); if(!mp[temp])&#123; que[!flag].push(temp); mp[temp] = true; &#125; &#125; &#125;else if(now == 'O')&#123; if( (q.first&amp;(1&lt;&lt;0)) != 0)&#123;//machine IO has printed I temp = make_pair(q.first-1, q.second+1); if(!mp[temp])&#123; que[!flag].push(temp); mp[temp] = true; &#125; &#125; if( (q.first&amp;(1&lt;&lt;2)) != 0)&#123;//machine iO has printed i temp = make_pair(q.first-4, q.second); if(!mp[temp])&#123; que[!flag].push(temp); mp[temp] = true; &#125; &#125; &#125;else&#123;//now is 'o' if( (q.first&amp;(1&lt;&lt;1)) != 0)&#123;//machine Io has printed I temp = make_pair(q.first-2, q.second); if(!mp[temp])&#123; que[!flag].push(temp); mp[temp] = true; &#125; &#125; if( (q.first&amp;(1&lt;&lt;3)) != 0)&#123;//machine io has printed i temp = make_pair(q.first-8, q.second); if(!mp[temp])&#123; que[!flag].push(temp); mp[temp] = true; &#125; &#125; &#125; &#125; flag = !flag; &#125; while(!que[flag].empty())&#123; pair&lt;int, int&gt; q = que[flag].front(); que[flag].pop(); ans = max(ans, q.second); &#125; printf("Case #%d: %d\n", rnd++, ans); &#125; return 0;&#125; Impromptu Outdoor Gallery题意:平面给$N(N\leq1200)$个点, 从中取4个点组成四边形(可凸可凹), 问能组成的四边形的最小面积2(2是为了保证计算都按整数算吧).分析:把四边形看成两个三角形的合成, 枚举所有线段视为对角线, 再从线段两边的找个最距离最小的点构成三角形. 现在问题就是如何$O(1)$地找到这样的点(毕竟枚举线段已经$O(N^2)$). 我先把wa的代码贴着吧, 不知道哪里写挂了,这题有原题bzoj3703.还有人迷之循环优化$O(N^3)$过了….神奇 code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int maxn = 1300;const long long inf = 9000000000000000000;pair&lt;long long, long long&gt; save[maxn];map&lt;pair&lt;long long, long long&gt;, int&gt; mp;long long getArea(pair&lt;long long,long long&gt; a, pair&lt;long long, long long&gt; b, pair&lt;long long, long long&gt; c)&#123; long long a11=b.first-a.first, a21=b.second-a.second, a12=c.first-a.first, a22=c.second-a.second; long long det = a11*a22-a12*a21; return det&lt;0?-det:det; return det;&#125;struct Line&#123; pair&lt;long long, long long&gt; sta, end; double slope; Line()&#123; sta = end = make_pair(0,0); slope = 0; &#125; Line(pair&lt;long long, long long&gt; x, pair&lt;long long, long long&gt; y)&#123; sta=x, end=y; if(x.first == y.first)&#123; slope = 1e60; &#125;else slope = ((y.second-x.second)*1.0f)/((y.first-x.first)*1.0f); &#125; bool operator&lt;(const Line&amp;n)const&#123; return slope &lt; n.slope; &#125;&#125;line[maxn*maxn];int main()&#123; int t, rnd=1; scanf("%d", &amp;t); while(t--)&#123; int n; scanf("%d", &amp;n); mp.clear(); for(int i=0; i&lt;n; i++)&#123; scanf("%lld%lld", &amp;save[i].first, &amp;save[i].second); &#125; sort(save, save+n); for(int i=0; i&lt;n; i++)&#123; mp[save[i]] = i; &#125; long long ans = inf; int m = 0; for(int i=0; i&lt;n; i++)&#123; for(int j=i+1; j&lt;n; j++)&#123; line[m++] = Line(save[i], save[j]); &#125; &#125; sort(line, line+m); for(int i=0; i&lt;m; i++)&#123; long long la = inf, ra = inf; if(mp[line[i].sta] &gt; mp[line[i].end]) swap(line[i].sta, line[i].end); if(mp[line[i].sta]&gt;0) la = getArea(line[i].sta, line[i].end, save[ mp[line[i].sta]-1 ]); if(mp[line[i].end]&lt;n-1) ra = getArea(line[i].sta, line[i].end, save[ mp[line[i].end]+1 ]); if(la!=inf &amp;&amp; ra!=inf) ans = min(ans, la+ra); swap(mp[line[i].sta], mp[line[i].end]); swap(save[mp[line[i].sta]], save[mp[line[i].end]]); &#125; printf("Case #%d: %lld\n", rnd++, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>代码题解</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再一次的刘汝佳紫书]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%86%8D%E4%B8%80%E6%AC%A1%E7%9A%84%E5%88%98%E6%B1%9D%E4%BD%B3%E7%B4%AB%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[补补紫书 第3章例题部分例题3-1 TEX Quotes UVa272简单的输入输出 code 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; int flag = false; char c; while( (c=getchar()) !=EOF)&#123; if(c == '"')&#123; if(!flag)&#123; printf("``"); flag = true; &#125; else&#123; printf("''"); flag = false; &#125; &#125;else printf("%c", c); &#125; return 0;&#125; 例题3-2 WERTYU UVa10082擅用数组 code 12345678910111213141516#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 110;char save[maxn] = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./\0";int main()&#123; char c; int len = sizeof(save); int i; while((c=getchar())!=EOF)&#123; for(i=0; i&lt;len&amp;&amp;save[i]!=c; i++); printf("%c", i==len?c:save[i-1]); &#125; return 0;&#125; 例题3-3 Palindromes UVa401回文与镜像操作 code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;char rev_ch[] = "A 3 HIL JM O 2TUVWXY5";char rev_in[] = "01SE Z 8 ";const int maxn = 1010;char save[maxn];int main()&#123; while(~scanf("%s", save))&#123; int len = strlen(save); int half = (len-1)/2; bool pali = true, mirr = true; for(int i=0; i&lt;=half; i++)&#123; if(save[i]!=save[len-1-i]) pali = false; if('A'&lt;=save[i]&amp;&amp;save[i]&lt;='Z')&#123; if(save[len-i-1] != rev_ch[save[i]-'A']) mirr = false; &#125;else&#123; if(save[len-i-1] != rev_in[save[i]-'0']) mirr = false; &#125; &#125; if(pali)&#123; if(mirr)&#123; printf("%s -- is a mirrored palindrome.", save); &#125;else&#123; printf("%s -- is a regular palindrome.", save); &#125; &#125;else&#123; if(mirr)&#123; printf("%s -- is a mirrored string.", save); &#125;else&#123; printf("%s -- is not a palindrome.", save); &#125; &#125; printf("\n\n"); &#125; return 0;&#125; 例题3-4 Master-Mind Hints UVa340普通计数 code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1010;int save[maxn];int in[maxn];int num[20];int num_cp[20];int main()&#123; int n, T=0; while(~scanf("%d", &amp;n))&#123; if(n==0) break; ++T; printf("Game %d:\n", T); for(int i=0; i&lt;10; i++) num[i] = 0; for(int i=0; i&lt;n; i++)&#123; scanf("%d", &amp;save[i]); ++num[save[i]]; &#125; while(1)&#123; memcpy(num_cp, num, sizeof(num)); bool end = true; int match=0, misMatch=0; for(int i=0; i&lt;n; i++)&#123; scanf("%d", &amp;in[i]); if(in[i] != 0) end = false; if(in[i]==save[i])&#123; ++match; --num_cp[in[i]]; &#125; &#125; for(int i=0; i&lt;n; i++)&#123; if(in[i]!=save[i]) if(num_cp[in[i]])&#123; ++misMatch; --num_cp[in[i]]; &#125; &#125; if(end) break; printf(" (%d, %d)\n", match, misMatch); &#125; &#125; return 0;&#125; 例题3-5 Digit Generator UVa1583打表 code 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100050;int save[maxn];int gen(int x)&#123; int ans = x; while(x)&#123; ans += x%10; x /= 10; &#125; return ans;&#125;int main()&#123; memset(save, 0, sizeof(save)); for(int i=1; i&lt;=100000; i++)&#123; int ge = gen(i); if(save[ge]==0) save[ge] = i; &#125; int N; while(~scanf("%d", &amp;N))&#123; int now; for(int i=0; i&lt;N; i++)&#123; scanf("%d", &amp;now); printf("%d\n", save[now]); &#125; &#125; return 0;&#125; 例题3-6 Circular Sequence UVa1584环状数组 code 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 110;char str[maxn];bool compare(int s1, int s2, int len)&#123; int p1 = s1, p2 = s2, p = 0; while(p&lt;len)&#123; ++p; if(str[p1%len] &lt; str[p2%len]) return true; else if(str[p1%len] &gt; str[p2%len]) return false; else&#123; ++p1; ++p2; &#125; &#125; return true;&#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; scanf("%s", str); int len = strlen(str); int p = 0, ans = 0; while(p&lt;len)&#123; if(compare(p, ans, len)) ans = p; ++p; &#125; p = ans; for(int i=0; i&lt;len; i++)&#123; printf("%c", str[p%len]); ++p; &#125; printf("\n"); &#125; return 0;&#125; 习题部分习题3-1 Score UVa1585普通计数 code 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100;char str[maxn];int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; scanf("%s", str); int ans = 0, combo = 0; int len = strlen(str); for(int i=0; i&lt;len; i++)&#123; if(str[i]=='O')&#123; combo++; ans += combo; if(str[i+1] != 'O')&#123; combo = 0; &#125; &#125; &#125; ans += combo; printf("%d\n", ans); &#125; return 0;&#125; 习题3-2 Molar mass简单字符串数字切割 code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 110;char str[maxn];double getVal(char tp, int num)&#123; if(tp=='C') return num*12.01; else if(tp=='H') return num*1.008; else if(tp=='O') return num*16.00; else return num*14.01;&#125;int str2int(int s, int e)&#123; int sum = 0, p = s; while(p&lt;=e)&#123; sum *= 10; sum += str[p]-'0'; ++p; &#125; return sum;&#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; double ans = 0.0f; int num = 0; scanf("%s", str); int p = 0, val = 0, len = strlen(str); char tp; bool counting = false; for(int i=0; i&lt;len; i++)&#123; if('A'&lt;=str[i]&amp;&amp;str[i]&lt;='Z')&#123; p = i+1; tp = str[i]; if('0'&gt;str[i+1]||str[i+1]&gt;'9')&#123; ans += getVal(tp, 1); &#125; &#125;else&#123; if(str[i+1]&lt;'0'||str[i+1]&gt;'9')&#123; val = str2int(p, i); ans += getVal(tp, val); &#125; &#125; &#125; printf("%.3lf\n", ans); &#125; return 0;&#125; 习题3-3 Digit Counting UVa1225普通地打了个表 code 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 10010;int res[maxn][10];void update(int num)&#123; int index = num; while(num)&#123; ++res[index][num%10]; num /= 10; &#125;&#125;int main()&#123; int T; scanf("%d", &amp;T); memset(res, 0, sizeof(res)); for(int i=1; i&lt;=10000; i++)&#123; memcpy(res[i], res[i-1], 10*sizeof(int)); update(i); &#125; while(T--)&#123; int n; scanf("%d", &amp;n); for(int i=0; i&lt;=9; i++)&#123; printf("%d%c", res[n][i], i==9?'\n':' '); &#125; &#125; return 0;&#125; 习题3-4 Periodic Strings UVa455最小周期串 code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100;char str[maxn];int main()&#123; int n; scanf("%d", &amp;n); while(n--)&#123; scanf("%s", str); int len = strlen(str), res = 1; while(res&lt;=len)&#123; if(len%res) &#123; ++res; continue; &#125; int rep = len/res; --rep; bool flag = true; while(rep)&#123; for(int i=0+res*rep, p=0; p&lt;res; i++,p++)&#123; if(str[p] != str[i])&#123; flag = false; break; &#125; &#125; --rep; if(!flag) break; &#125; if(flag) break; ++res; &#125; printf("%d\n", res); if(n!=0) printf("\n"); &#125; return 0;&#125; 习题3-5 Puzzle UVa227输入输出有点卡人… 学会了使用fgets..以前都在使用危险的gets我每次switch都忘记写break呢 code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 10;char puzz[maxn][maxn];int main()&#123; int sx, sy; int rnd = 1; bool first = true; while(fgets(puzz[0], maxn, stdin) != NULL)&#123; if(strlen(puzz[0])&lt;5 &amp;&amp; puzz[0][0]=='Z')&#123; break; &#125; if(first) first = false; else printf("\n"); for(int i=1; i&lt;5; i++)&#123; fgets(puzz[i], maxn, stdin); &#125; for(int i=0; i&lt;5; i++) for(int j=0; j&lt;5; j++)&#123; if(puzz[i][j] == ' ')&#123; sx = i; sy = j; &#125; &#125; char op[110]; bool flag = true; while(~scanf("%s", op))&#123; getchar(); int len = strlen(op); bool bre = false; for(int i=0; i&lt;len; i++)&#123; switch(op[i])&#123; case 'A': if(0&lt;=sx-1)&#123; swap(puzz[sx][sy], puzz[sx-1][sy]); sx -= 1; &#125;else flag = false; break; case 'B': if(5&gt;sx+1)&#123; swap(puzz[sx][sy], puzz[sx+1][sy]); sx += 1; &#125;else flag = false; break; case 'L': if(0&lt;=sy-1)&#123; swap(puzz[sx][sy], puzz[sx][sy-1]); sy -= 1; &#125;else flag = false; break; case 'R': if(5&gt;sy+1)&#123; swap(puzz[sx][sy], puzz[sx][sy+1]); sy += 1; &#125;else flag = false; break; default: if(op[i]!='0') flag = false; else bre = true; &#125; &#125; if(bre) break; &#125; printf("Puzzle #%d:\n", rnd++); if(!flag)&#123; printf("This puzzle has no final configuration.\n"); &#125;else&#123; for(int i=0; i&lt;5; i++)&#123; for(int j=0; j&lt;5; j++)&#123; printf("%c%c", puzz[i][j], j==4?'\n':' '); &#125; &#125; &#125; &#125; return 0;&#125; 习题3-6 Crossword Answers UVa232嗯…无感想 code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int maxn = 15;char puzz[maxn][maxn];bool used[maxn][maxn];vector&lt;pair&lt;int,int&gt; &gt; strBlock;void add(int x, int y, int &amp;num)&#123; strBlock.push_back(make_pair(x, y));&#125;void print(int i)&#123; if(i+1&lt;10) printf(" %d.", i+1); else if(10&lt;=i+1&amp;&amp;i+1&lt;100) printf(" %d.", i+1); else printf("%d.", i+1);&#125;int main()&#123; int r, c; int rnd = 1; bool first = true; while(~scanf("%d", &amp;r))&#123; if(!r) break; if(first) first = 0; else printf("\n"); strBlock.clear(); scanf("%d", &amp;c); int num = 0; for(int i=0; i&lt;r; i++)&#123; scanf("%s", puzz[i]); for(int j=0; j&lt;c; j++)&#123; if(puzz[i][j]!='*')&#123; if(j-1&lt;0 || i-1&lt;0) &#123; add(i, j, num); &#125;else if(0&lt;=j-1&amp;&amp;puzz[i][j-1]=='*')&#123; add(i, j, num); &#125;else if(0&lt;=i-1&amp;&amp;puzz[i-1][j]=='*')&#123; add(i, j, num); &#125; &#125; &#125; &#125; int len = strBlock.size(); memset(used, 0, sizeof(used)); printf("puzzle #%d:\nAcross\n", rnd++); for(int i=0; i&lt;len; i++)&#123; int px = strBlock[i].first; int py = strBlock[i].second; if(used[px][py]) continue; print(i); while(py&lt;c &amp;&amp; puzz[px][py]!='*')&#123; used[px][py] = true; printf("%c", puzz[px][py]); ++py; &#125; printf("\n"); &#125; printf("Down\n"); memset(used, 0, sizeof(used)); for(int i=0; i&lt;len; i++)&#123; int px = strBlock[i].first; int py = strBlock[i].second; if(used[px][py]) continue; print(i); while(px&lt;r &amp;&amp; puzz[px][py]!='*')&#123; used[px][py] = true; printf("%c", puzz[px][py]); ++px; &#125; printf("\n"); &#125; &#125; return 0;&#125; 习题3-7 DNA Consensus String UVa1368记个数 code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;char str[60][1010];int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; int m, n; scanf("%d%d", &amp;m, &amp;n); for(int i=0; i&lt;m; i++)&#123; scanf("%s", str[i]); &#125; int ans = 0; for(int j=0; j&lt;n; j++)&#123; int sum[4]; memset(sum, 0, sizeof(sum)); for(int i=0; i&lt;m; i++)&#123; switch(str[i][j])&#123; case 'A': ++sum[0]; break; case 'C': ++sum[1]; break; case 'G': ++sum[2]; break; case 'T': ++sum[3]; break; default: break; &#125; &#125; if(sum[0]&gt;=sum[1] &amp;&amp; sum[0]&gt;=sum[2] &amp;&amp; sum[0]&gt;=sum[3])&#123; printf("A"); ans += sum[1]+sum[2]+sum[3]; &#125;else if(sum[1]&gt;=sum[0] &amp;&amp; sum[1]&gt;=sum[2] &amp;&amp; sum[1]&gt;=sum[3])&#123; printf("C"); ans += sum[0]+sum[2]+sum[3]; &#125;else if(sum[2]&gt;=sum[0] &amp;&amp; sum[2]&gt;=sum[1] &amp;&amp; sum[2]&gt;=sum[3])&#123; printf("G"); ans += sum[0]+sum[1]+sum[3]; &#125;else&#123; printf("T"); ans += sum[0]+sum[1]+sum[2]; &#125; &#125; printf("\n%d\n", ans); &#125; return 0;&#125; 习题3-8 Repeating Decimals UVa202手写大数除法的基础? code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 3010;int used[maxn];int ans[100010];int main()&#123; int a, b, c; while(~scanf("%d%d", &amp;a, &amp;b))&#123; memset(used, 0, sizeof(used)); c = a/b; printf("%d/%d = %d.", a, b, c); int rep = 0, sta = 1; a -= c*b; while(a%b)&#123; if(used[a]) &#123; sta = used[a]; break; &#125;else used[a] = rep+1; a *= 10; c = a/b; ans[++rep] = c; a -= c*b; &#125; bool div = false; if(rep&lt;=50)&#123; if(a%b==0)&#123; div = true; for(int i=1; i&lt;=rep; i++) printf("%d", ans[i]); printf("(0)\n"); &#125;else&#123; for(int i=1; i&lt;sta; i++) printf("%d", ans[i]); printf("("); for(int i=sta; i&lt;=rep; i++) printf("%d", ans[i]); printf(")\n"); &#125; &#125;else&#123; if(a%b==0)&#123; div = true; for(int i=1; i&lt;=50; i++) printf("%d", ans[i]); printf("...\n"); &#125;else&#123; for(int i=1; i&lt;sta; i++) printf("%d", ans[i]); printf("("); for(int i=sta; i&lt;=50; i++) printf("%d", ans[i]); printf("...)\n"); &#125; &#125; printf(" %d = number of digits in repeating cycle\n\n", div?1:rep+1-sta); &#125; return 0;&#125; 习题3-9 All in All UVa10340初看以为是最大公共子串, 但其实只要遍历母串时看看子串是否匹配就好惹 code 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100010;char str[maxn], pat[maxn];int main()&#123; while(~scanf("%s%s", pat, str))&#123; int lens = strlen(str), lenp = strlen(pat); int p = 0; for(int i=0; i&lt;lens; i++)&#123; if(p&lt;lenp &amp;&amp; str[i] == pat[p]) ++p; &#125; if(p==lenp) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 习题3-10 Box UVa1587先把六个面排序, 筛选出三个面来, 如果能组成长方体的话这三个面的边长有逻辑关系, 写个判断 code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn =1010;pair&lt;int, int&gt; cov[10];bool vis[maxn];bool can(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b, pair&lt;int, int&gt; c)&#123; if(a.first==b.first)&#123; if(a.second == c. first)&#123; if(c.second == b.second) return true; &#125;else if(a.second == c.second)&#123; if(c.first == b.second) return true; &#125; &#125; return false;&#125;int main()&#123; while(~scanf("%d%d", &amp;cov[0].first, &amp;cov[0].second))&#123; memset(vis, 0, sizeof(vis)); for(int i=1; i&lt;6; i++)&#123; scanf("%d%d", &amp;cov[i].first, &amp;cov[i].second); &#125; for(int i=0; i&lt;6; i++)&#123; if(cov[i].first &gt; cov[i].second) swap(cov[i].first, cov[i].second); &#125; sort(cov, cov+6); bool flag = true; for(int i=0; i&lt;6; i+=2)&#123; if(cov[i]!=cov[i+1]) flag = false; &#125; if(!can(cov[0], cov[2], cov[4])) flag = false; if(flag) printf("POSSIBLE\n"); else printf("IMPOSSIBLE\n"); &#125; return 0;&#125; 习题3-11 Kickdown UVa1588wa了很久…玉山啊..边界条件不考虑清楚就写…. code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;char s1[maxn], s2[maxn];int main()&#123; while(~scanf("%s%s", s1, s2))&#123; int len1 = strlen(s1), len2 = strlen(s2); if(len1&gt;len2)&#123; swap(s1, s2); swap(len1, len2); &#125; int ans = len1+len2; bool flag; for(int i=0; i&lt;len1; i++)&#123; flag = true; for(int j=0; i+j&lt;len1; j++)&#123; if( (s1[i+j]-'0')+(s2[j]-'0') &gt;3)&#123; flag = false; break; &#125; &#125; if(flag)&#123; if(ans &gt; i+len2) &#123; ans = i+len2; &#125; &#125; &#125; for(int i=0; i&lt;len2; i++)&#123; flag = true; for(int j=0; i+j&lt;len2 &amp;&amp; j&lt;len1; j++)&#123; if( (s1[j]-'0')+(s2[i+j]-'0')&gt;3 )&#123; flag = false; break; &#125; &#125; if(flag)&#123; int now = max(i+len1, len2); if(ans &gt; now)&#123; ans = now; &#125; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; 习题3-12 Floating-Point Numbers UVa11809这题好玩, 题面复习了一遍浮点数在计算机内是如何存储的.上图中8-bit用来存储Mantissa(尾数), 6-bit用于存储exponent(阶码).本题默认首位为0, 即表示的是正数. 图中8-bit Mantissa+6-bit expnent最大能表示的浮点数为$0.11111111_2\times 2^{111111_2}=0.998046875 \times 2^{63}=9.205357638345293824e18$, 我们记为$M_2\times 2^{E_2}=A\times 10^B$ 现在以$A\times 10^B$的形式输入计算机能表示的最大浮点数, 求M, E的位数. 直接算很麻烦, 由于题目明确说明$0\le M\le 9, 1\le E\le 30$, 所以我们可以直接打表, 把10*30种情况打出来. 还有一个问题, $2^{E_2}$会非常大,直接算会变成inf. 此处使用一个log操作:$log(M_2\times 2^{E_2})=log(A\times 10^B)$ $logM_2+ E_2\times log2=logA+ B$ code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const double logt = log10(2);const double eps = 1e-6;double base[2] = &#123;0.1, 10&#125;;double save[15][35];double str2dou(char* str, int len)&#123; bool flag = true; double now = 1, ans = 0; for(int i=0; i&lt;len; i++)&#123; if(str[i]=='.')&#123; flag = false; now = 0.1; &#125;else&#123; if(flag)&#123; ans*=10; ans += str[i]-'0'; &#125;else&#123; ans += (str[i]-'0')*now; now *= base[flag]; &#125; &#125; &#125; return ans;&#125;void init()&#123; double sum1 = 0; double now1 = 0.5; for(int m=0; m&lt;=9; m++)&#123; sum1 += now1; now1 /= 2; double sum2 = 0; double now2 = 1; for(int e=1; e&lt;=30; e++)&#123; sum2 += now2; now2 *= 2; save[m][e] = log10(sum1) + sum2*logt; &#125; &#125;&#125;int main()&#123; char str[110]; init(); while(~scanf("%s", str))&#123; int pos_e; int len = strlen(str); for(pos_e=0; str[pos_e]!='e'; pos_e++); str[pos_e] = '\0'; char* A = str; char* B = str+pos_e+1; int lenA = strlen(A), lenB = strlen(B); if(lenA==1 &amp;&amp; lenB==1 &amp;&amp; A[0]=='0' &amp;&amp; B[0]=='0') break; double a = str2dou(A, lenA), b = str2dou(B, lenB); bool found = false; for(int m=0; m&lt;=9; m++)&#123; for(int e=1; e&lt;=30; e++)&#123; if(abs(log10(a)+b - save[m][e])&lt;eps)&#123; found = true; printf("%d %d\n", m, e); break; &#125; &#125; if(found) break; &#125; &#125; return 0;&#125; 第4章例题部分例题4-1 Ancient Cipher UVa1339时隔一年的排序 code 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;int main()&#123; char a[maxn], b[maxn]; int staa[26], stab[26]; while(~scanf("%s%s", a, b))&#123; memset(staa, 0, sizeof(staa)); memset(stab, 0, sizeof(stab)); int len = strlen(a); for(int i=0; i&lt;len; i++)&#123; staa[a[i]-'A']++; stab[b[i]-'A']++; &#125; sort(staa, staa+26); sort(stab, stab+26); bool flag = true; for(int i=0; i&lt;26; i++)&#123; if(staa[i]!=stab[i])&#123; flag = false; break; &#125; &#125; if(flag) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 习题4-2 Hangman Judge UVa48912 习题部分]]></content>
      <categories>
        <category>代码题解</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日求点到超平面距离]]></title>
    <url>%2F2019%2F08%2F27%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%B1%82%E7%82%B9%E5%88%B0%E8%B6%85%E5%B9%B3%E9%9D%A2%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[文文问怎么推导点到超平面的距离, 除了把它想成Least squares问题外, 这也是一个在给定约束条件下求极值的问题, 顺便测试一下hexo数学符号显示怎么样,新博客的第一篇就写下使用Lagrange multiplier来求这个条件极值问题吧. 先从超平面入手, 超平面的定义是余空间仅为一维的集合, 先设$n$维空间中一点为$\vec x_0=(X_1, X_2,…,X_n)$, 并设超平面的约束条件为$\vec w^T\vec x =b$,其中$\vec w$为$n\times 1$向量.那么我们可以写出Lagrange multiplier:$\mathrm L(\vec x, \lambda)=||\vec x-\vec x_0||^2+\lambda (\vec w^T\vec x-\vec b)$ 求个偏微分: $\frac{\partial L}{\partial \vec x} = 2(\vec x - \vec x_0)+\lambda \vec w =\vec 0$$\frac{\partial L}{\partial \lambda} = \vec w^T\vec x-\vec b=0$ From $\frac{\partial L}{\partial \lambda}$ we obtain:$\vec w^T\vec x-b=0\to\vec w^T\vec x -\vec w^t\vec x_0+\vec w^t\vec x_0-b=0\to \vec w^t(\vec x-\vec x_0)=-\vec w^t\vec x_0+b$将$\frac{\partial L}{\partial \vec x}$左右两边同乘以$\vec w^T:$$2\vec w^T(\vec x - \vec x_0)+\lambda \vec w^T\vec w =\vec 0$然后把刚刚推出来的式子代入$2(\vec w^T\vec x_0-b)=\lambda||\vec w||^2$得出$\lambda=\frac{2(\vec w^T\vec x_0-b)}{||\vec w||^2}$将$\lambda$回代入$\frac{\partial L}{\partial \vec x}$中:$2(\vec x - \vec x_0)+ \frac{2(\vec w^T\vec x_0-b)}{||\vec w||^2}\vec w =\vec 0$得到$(\vec x - \vec x_0)=-\frac{(\vec w^T\vec x_0-b)}{||\vec w||^2}\vec w$ 求个长度便得到距离:$||\vec x - \vec x_0||=|\frac{(\vec w^T\vec x_0-b)}{||\vec w||}|$ 昨天我不知道超平面的定义,导致和文文讲话不在同一个频道. 我以为给定的约束条件中W是个矩阵, 在这个约束条件下$\vec x$的集合就不一定是超平面了. 那么在约束条件$W\vec x=\vec b$下, 问题会是怎样呢? 再废话讲一下前提. 设$n$维空间中一点为$\vec x_0=(X_1, X_2,…,X_n)$, 并设集合$S={\vec x\in \mathbb R^n|W\vec x=\vec b}$约束条件为$W\vec x =\vec b$.其中W为一个$n\times n$的矩阵, $\vec x, \vec b$是$n\times 1$的向量. 那么令$\vec x=(x_1,…,x_n), \vec \lambda=(\lambda_1, …, \lambda_n)$, Lagrange multiplier为: $\mathrm L(\vec x, \vec \lambda)=||\vec x-\vec x_0||^2+\vec \lambda^T(W\vec x-\vec b)$ 求个偏微分:$\frac{\partial L}{\partial \vec x}=2(\vec x-\vec x_0)+W^T\vec \lambda=\vec 0$$\frac{\partial L}{\partial \vec \lambda}=W\vec x-\vec b = \vec 0$ Similarly, from$\frac{\partial L}{\partial \vec \lambda}$we obtain:$W\vec x-W\vec x_0 +W\vec x_0-\vec b=\vec 0\to W(\vec x-\vec x_0)=-W\vec x_0+\vec b$.Both sides of $\frac{\partial L}{\partial \vec x}$ multiply by W:$2W(\vec x-\vec x_0)+WW^T\vec \lambda=\vec 0$Substitute the equation obtained from$\frac{\partial L}{\partial \vec \lambda}$ into $\frac{\partial L}{\partial \vec x}$ we get: $2(W\vec x_0-\vec b)=WW^T\vec \lambda$ Since $WW^T$ is symmetrical, so it’s invertiable. So $\vec \lambda$ is: $\vec \lambda=2(WW^T)^{-1}(W\vec x_0-\vec b)$Substitute $\vec \lambda$ into $\frac{\partial L}{\partial \vec x}$:$2(\vec x-\vec x_0)+2W^T(WW^T)^{-1}(W\vec x_0-\vec b)=\vec 0$Finally we obtain $\vec x-\vec x_0=||W^T(WW^T)^{-1}(W\vec x_0-\vec b)||$ Fuck type too many words.]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>mathematics</tag>
        <tag>Lagrange multiplier</tag>
        <tag>Linear Algbra</tag>
      </tags>
  </entry>
</search>
