<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Soulutions-->Code Jam to I/O for Women]]></title>
    <url>%2F2019%2F10%2F04%2FSoulutions-Code-Jam-to-I-O-for-Women%2F</url>
    <content type="text"><![CDATA[何夜无月何处无竹柏]]></content>
      <categories>
        <category>代码题解</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再一次的刘汝佳紫书]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%86%8D%E4%B8%80%E6%AC%A1%E7%9A%84%E5%88%98%E6%B1%9D%E4%BD%B3%E7%B4%AB%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[重新捡起紫书…为了kickstart冲哇 2019.9.23为什么国庆节要搞我的服务器!!!!!!!!!!!!!!!!! 2019.9.27现在买ps4是不是相当于49年入国军? 2019.9.28早买早享受, 剁啦!!! 苏利文大叔、乔尔老爹我来了!!真希望快递小哥能快一点,再快一点,翘首以盼还买了个键盘,最便宜的那种薄膜, 但是敲得我好爽啊就等我的电脑支架, 保护颈椎今日开始 2019.9.29为何我的vim这么卡 第3章例题部分例题3-1 TEX Quotes UVa272简单的输入输出 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; int flag = false; char c; while( (c=getchar()) !=EOF)&#123; if(c == '"')&#123; if(!flag)&#123; printf("``"); flag = true; &#125; else&#123; printf("''"); flag = false; &#125; &#125;else printf("%c", c); &#125; return 0;&#125; 例题3-2 WERTYU UVa10082擅用数组 12345678910111213141516#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 110;char save[maxn] = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./\0";int main()&#123; char c; int len = sizeof(save); int i; while((c=getchar())!=EOF)&#123; for(i=0; i&lt;len&amp;&amp;save[i]!=c; i++); printf("%c", i==len?c:save[i-1]); &#125; return 0;&#125; 例题3-3 Palindromes UVa401回文与镜像操作 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;char rev_ch[] = "A 3 HIL JM O 2TUVWXY5";char rev_in[] = "01SE Z 8 ";const int maxn = 1010;char save[maxn];int main()&#123; while(~scanf("%s", save))&#123; int len = strlen(save); int half = (len-1)/2; bool pali = true, mirr = true; for(int i=0; i&lt;=half; i++)&#123; if(save[i]!=save[len-1-i]) pali = false; if('A'&lt;=save[i]&amp;&amp;save[i]&lt;='Z')&#123; if(save[len-i-1] != rev_ch[save[i]-'A']) mirr = false; &#125;else&#123; if(save[len-i-1] != rev_in[save[i]-'0']) mirr = false; &#125; &#125; if(pali)&#123; if(mirr)&#123; printf("%s -- is a mirrored palindrome.", save); &#125;else&#123; printf("%s -- is a regular palindrome.", save); &#125; &#125;else&#123; if(mirr)&#123; printf("%s -- is a mirrored string.", save); &#125;else&#123; printf("%s -- is not a palindrome.", save); &#125; &#125; printf("\n\n"); &#125; return 0;&#125; 例题3-4 Master-Mind Hints UVa340普通计数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1010;int save[maxn];int in[maxn];int num[20];int num_cp[20];int main()&#123; int n, T=0; while(~scanf("%d", &amp;n))&#123; if(n==0) break; ++T; printf("Game %d:\n", T); for(int i=0; i&lt;10; i++) num[i] = 0; for(int i=0; i&lt;n; i++)&#123; scanf("%d", &amp;save[i]); ++num[save[i]]; &#125; while(1)&#123; memcpy(num_cp, num, sizeof(num)); bool end = true; int match=0, misMatch=0; for(int i=0; i&lt;n; i++)&#123; scanf("%d", &amp;in[i]); if(in[i] != 0) end = false; if(in[i]==save[i])&#123; ++match; --num_cp[in[i]]; &#125; &#125; for(int i=0; i&lt;n; i++)&#123; if(in[i]!=save[i]) if(num_cp[in[i]])&#123; ++misMatch; --num_cp[in[i]]; &#125; &#125; if(end) break; printf(" (%d, %d)\n", match, misMatch); &#125; &#125; return 0;&#125; 例题3-5 Digit Generator UVa1583打表 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100050;int save[maxn];int gen(int x)&#123; int ans = x; while(x)&#123; ans += x%10; x /= 10; &#125; return ans;&#125;int main()&#123; memset(save, 0, sizeof(save)); for(int i=1; i&lt;=100000; i++)&#123; int ge = gen(i); if(save[ge]==0) save[ge] = i; &#125; int N; while(~scanf("%d", &amp;N))&#123; int now; for(int i=0; i&lt;N; i++)&#123; scanf("%d", &amp;now); printf("%d\n", save[now]); &#125; &#125; return 0;&#125; 例题3-6 Circular Sequence UVa1584环状数组 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 110;char str[maxn];bool compare(int s1, int s2, int len)&#123; int p1 = s1, p2 = s2, p = 0; while(p&lt;len)&#123; ++p; if(str[p1%len] &lt; str[p2%len]) return true; else if(str[p1%len] &gt; str[p2%len]) return false; else&#123; ++p1; ++p2; &#125; &#125; return true;&#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; scanf("%s", str); int len = strlen(str); int p = 0, ans = 0; while(p&lt;len)&#123; if(compare(p, ans, len)) ans = p; ++p; &#125; p = ans; for(int i=0; i&lt;len; i++)&#123; printf("%c", str[p%len]); ++p; &#125; printf("\n"); &#125; return 0;&#125; 习题部分习题3-1 Score UVa1585普通计数 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100;char str[maxn];int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; scanf("%s", str); int ans = 0, combo = 0; int len = strlen(str); for(int i=0; i&lt;len; i++)&#123; if(str[i]=='O')&#123; combo++; ans += combo; if(str[i+1] != 'O')&#123; combo = 0; &#125; &#125; &#125; ans += combo; printf("%d\n", ans); &#125; return 0;&#125; 习题3-2 Molar mass简单字符串数字切割 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 110;char str[maxn];double getVal(char tp, int num)&#123; if(tp=='C') return num*12.01; else if(tp=='H') return num*1.008; else if(tp=='O') return num*16.00; else return num*14.01;&#125;int str2int(int s, int e)&#123; int sum = 0, p = s; while(p&lt;=e)&#123; sum *= 10; sum += str[p]-'0'; ++p; &#125; return sum;&#125;int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; double ans = 0.0f; int num = 0; scanf("%s", str); int p = 0, val = 0, len = strlen(str); char tp; bool counting = false; for(int i=0; i&lt;len; i++)&#123; if('A'&lt;=str[i]&amp;&amp;str[i]&lt;='Z')&#123; p = i+1; tp = str[i]; if('0'&gt;str[i+1]||str[i+1]&gt;'9')&#123; ans += getVal(tp, 1); &#125; &#125;else&#123; if(str[i+1]&lt;'0'||str[i+1]&gt;'9')&#123; val = str2int(p, i); ans += getVal(tp, val); &#125; &#125; &#125; printf("%.3lf\n", ans); &#125; return 0;&#125; 习题3-3 Digit Counting UVa1225普通地打了个表 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 10010;int res[maxn][10];void update(int num)&#123; int index = num; while(num)&#123; ++res[index][num%10]; num /= 10; &#125;&#125;int main()&#123; int T; scanf("%d", &amp;T); memset(res, 0, sizeof(res)); for(int i=1; i&lt;=10000; i++)&#123; memcpy(res[i], res[i-1], 10*sizeof(int)); update(i); &#125; while(T--)&#123; int n; scanf("%d", &amp;n); for(int i=0; i&lt;=9; i++)&#123; printf("%d%c", res[n][i], i==9?'\n':' '); &#125; &#125; return 0;&#125; 习题3-4 Periodic Strings UVa455最小周期串 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100;char str[maxn];int main()&#123; int n; scanf("%d", &amp;n); while(n--)&#123; scanf("%s", str); int len = strlen(str), res = 1; while(res&lt;=len)&#123; if(len%res) &#123; ++res; continue; &#125; int rep = len/res; --rep; bool flag = true; while(rep)&#123; for(int i=0+res*rep, p=0; p&lt;res; i++,p++)&#123; if(str[p] != str[i])&#123; flag = false; break; &#125; &#125; --rep; if(!flag) break; &#125; if(flag) break; ++res; &#125; printf("%d\n", res); if(n!=0) printf("\n"); &#125; return 0;&#125; 习题3-5 Puzzle UVa227输入输出有点卡人… 学会了使用fgets..以前都在使用危险的gets我每次switch都忘记写break呢 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 10;char puzz[maxn][maxn];int main()&#123; int sx, sy; int rnd = 1; bool first = true; while(fgets(puzz[0], maxn, stdin) != NULL)&#123; if(strlen(puzz[0])&lt;5 &amp;&amp; puzz[0][0]=='Z')&#123; break; &#125; if(first) first = false; else printf("\n"); for(int i=1; i&lt;5; i++)&#123; fgets(puzz[i], maxn, stdin); &#125; for(int i=0; i&lt;5; i++) for(int j=0; j&lt;5; j++)&#123; if(puzz[i][j] == ' ')&#123; sx = i; sy = j; &#125; &#125; char op[110]; bool flag = true; while(~scanf("%s", op))&#123; getchar(); int len = strlen(op); bool bre = false; for(int i=0; i&lt;len; i++)&#123; switch(op[i])&#123; case 'A': if(0&lt;=sx-1)&#123; swap(puzz[sx][sy], puzz[sx-1][sy]); sx -= 1; &#125;else flag = false; break; case 'B': if(5&gt;sx+1)&#123; swap(puzz[sx][sy], puzz[sx+1][sy]); sx += 1; &#125;else flag = false; break; case 'L': if(0&lt;=sy-1)&#123; swap(puzz[sx][sy], puzz[sx][sy-1]); sy -= 1; &#125;else flag = false; break; case 'R': if(5&gt;sy+1)&#123; swap(puzz[sx][sy], puzz[sx][sy+1]); sy += 1; &#125;else flag = false; break; default: if(op[i]!='0') flag = false; else bre = true; &#125; &#125; if(bre) break; &#125; printf("Puzzle #%d:\n", rnd++); if(!flag)&#123; printf("This puzzle has no final configuration.\n"); &#125;else&#123; for(int i=0; i&lt;5; i++)&#123; for(int j=0; j&lt;5; j++)&#123; printf("%c%c", puzz[i][j], j==4?'\n':' '); &#125; &#125; &#125; &#125; return 0;&#125; 习题3-6 Crossword Answers UVa232嗯…无感想 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int maxn = 15;char puzz[maxn][maxn];bool used[maxn][maxn];vector&lt;pair&lt;int,int&gt; &gt; strBlock;void add(int x, int y, int &amp;num)&#123; strBlock.push_back(make_pair(x, y));&#125;void print(int i)&#123; if(i+1&lt;10) printf(" %d.", i+1); else if(10&lt;=i+1&amp;&amp;i+1&lt;100) printf(" %d.", i+1); else printf("%d.", i+1);&#125;int main()&#123; int r, c; int rnd = 1; bool first = true; while(~scanf("%d", &amp;r))&#123; if(!r) break; if(first) first = 0; else printf("\n"); strBlock.clear(); scanf("%d", &amp;c); int num = 0; for(int i=0; i&lt;r; i++)&#123; scanf("%s", puzz[i]); for(int j=0; j&lt;c; j++)&#123; if(puzz[i][j]!='*')&#123; if(j-1&lt;0 || i-1&lt;0) &#123; add(i, j, num); &#125;else if(0&lt;=j-1&amp;&amp;puzz[i][j-1]=='*')&#123; add(i, j, num); &#125;else if(0&lt;=i-1&amp;&amp;puzz[i-1][j]=='*')&#123; add(i, j, num); &#125; &#125; &#125; &#125; int len = strBlock.size(); memset(used, 0, sizeof(used)); printf("puzzle #%d:\nAcross\n", rnd++); for(int i=0; i&lt;len; i++)&#123; int px = strBlock[i].first; int py = strBlock[i].second; if(used[px][py]) continue; print(i); while(py&lt;c &amp;&amp; puzz[px][py]!='*')&#123; used[px][py] = true; printf("%c", puzz[px][py]); ++py; &#125; printf("\n"); &#125; printf("Down\n"); memset(used, 0, sizeof(used)); for(int i=0; i&lt;len; i++)&#123; int px = strBlock[i].first; int py = strBlock[i].second; if(used[px][py]) continue; print(i); while(px&lt;r &amp;&amp; puzz[px][py]!='*')&#123; used[px][py] = true; printf("%c", puzz[px][py]); ++px; &#125; printf("\n"); &#125; &#125; return 0;&#125; 习题3-7 DNA Consensus String UVa1368记个数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;char str[60][1010];int main()&#123; int T; scanf("%d", &amp;T); while(T--)&#123; int m, n; scanf("%d%d", &amp;m, &amp;n); for(int i=0; i&lt;m; i++)&#123; scanf("%s", str[i]); &#125; int ans = 0; for(int j=0; j&lt;n; j++)&#123; int sum[4]; memset(sum, 0, sizeof(sum)); for(int i=0; i&lt;m; i++)&#123; switch(str[i][j])&#123; case 'A': ++sum[0]; break; case 'C': ++sum[1]; break; case 'G': ++sum[2]; break; case 'T': ++sum[3]; break; default: break; &#125; &#125; if(sum[0]&gt;=sum[1] &amp;&amp; sum[0]&gt;=sum[2] &amp;&amp; sum[0]&gt;=sum[3])&#123; printf("A"); ans += sum[1]+sum[2]+sum[3]; &#125;else if(sum[1]&gt;=sum[0] &amp;&amp; sum[1]&gt;=sum[2] &amp;&amp; sum[1]&gt;=sum[3])&#123; printf("C"); ans += sum[0]+sum[2]+sum[3]; &#125;else if(sum[2]&gt;=sum[0] &amp;&amp; sum[2]&gt;=sum[1] &amp;&amp; sum[2]&gt;=sum[3])&#123; printf("G"); ans += sum[0]+sum[1]+sum[3]; &#125;else&#123; printf("T"); ans += sum[0]+sum[1]+sum[2]; &#125; &#125; printf("\n%d\n", ans); &#125; return 0;&#125; 习题3-8 Repeating Decimals UVa202手写大数除法的基础? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 3010;int used[maxn];int ans[100010];int main()&#123; int a, b, c; while(~scanf("%d%d", &amp;a, &amp;b))&#123; memset(used, 0, sizeof(used)); c = a/b; printf("%d/%d = %d.", a, b, c); int rep = 0, sta = 1; a -= c*b; while(a%b)&#123; if(used[a]) &#123; sta = used[a]; break; &#125;else used[a] = rep+1; a *= 10; c = a/b; ans[++rep] = c; a -= c*b; &#125; bool div = false; if(rep&lt;=50)&#123; if(a%b==0)&#123; div = true; for(int i=1; i&lt;=rep; i++) printf("%d", ans[i]); printf("(0)\n"); &#125;else&#123; for(int i=1; i&lt;sta; i++) printf("%d", ans[i]); printf("("); for(int i=sta; i&lt;=rep; i++) printf("%d", ans[i]); printf(")\n"); &#125; &#125;else&#123; if(a%b==0)&#123; div = true; for(int i=1; i&lt;=50; i++) printf("%d", ans[i]); printf("...\n"); &#125;else&#123; for(int i=1; i&lt;sta; i++) printf("%d", ans[i]); printf("("); for(int i=sta; i&lt;=50; i++) printf("%d", ans[i]); printf("...)\n"); &#125; &#125; printf(" %d = number of digits in repeating cycle\n\n", div?1:rep+1-sta); &#125; return 0;&#125; 习题3-9 All in All UVa10340初看以为是最大公共子串, 但其实只要遍历母串时看看子串是否匹配就好惹 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100010;char str[maxn], pat[maxn];int main()&#123; while(~scanf("%s%s", pat, str))&#123; int lens = strlen(str), lenp = strlen(pat); int p = 0; for(int i=0; i&lt;lens; i++)&#123; if(p&lt;lenp &amp;&amp; str[i] == pat[p]) ++p; &#125; if(p==lenp) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 习题3-10 Box UVa1587先把六个面排序, 筛选出三个面来, 如果能组成长方体的话这三个面的边长有逻辑关系, 写个判断 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn =1010;pair&lt;int, int&gt; cov[10];bool vis[maxn];bool can(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b, pair&lt;int, int&gt; c)&#123; if(a.first==b.first)&#123; if(a.second == c. first)&#123; if(c.second == b.second) return true; &#125;else if(a.second == c.second)&#123; if(c.first == b.second) return true; &#125; &#125; return false;&#125;int main()&#123; while(~scanf("%d%d", &amp;cov[0].first, &amp;cov[0].second))&#123; memset(vis, 0, sizeof(vis)); for(int i=1; i&lt;6; i++)&#123; scanf("%d%d", &amp;cov[i].first, &amp;cov[i].second); &#125; for(int i=0; i&lt;6; i++)&#123; if(cov[i].first &gt; cov[i].second) swap(cov[i].first, cov[i].second); &#125; sort(cov, cov+6); bool flag = true; for(int i=0; i&lt;6; i+=2)&#123; if(cov[i]!=cov[i+1]) flag = false; &#125; if(!can(cov[0], cov[2], cov[4])) flag = false; if(flag) printf("POSSIBLE\n"); else printf("IMPOSSIBLE\n"); &#125; return 0;&#125; 习题3-11 Kickdown UVa1588wa了很久…玉山啊..边界条件不考虑清楚就写…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;char s1[maxn], s2[maxn];int main()&#123; while(~scanf("%s%s", s1, s2))&#123; int len1 = strlen(s1), len2 = strlen(s2); if(len1&gt;len2)&#123; swap(s1, s2); swap(len1, len2); &#125; int ans = len1+len2; bool flag; for(int i=0; i&lt;len1; i++)&#123; flag = true; for(int j=0; i+j&lt;len1; j++)&#123; if( (s1[i+j]-'0')+(s2[j]-'0') &gt;3)&#123; flag = false; break; &#125; &#125; if(flag)&#123; if(ans &gt; i+len2) &#123; ans = i+len2; &#125; &#125; &#125; for(int i=0; i&lt;len2; i++)&#123; flag = true; for(int j=0; i+j&lt;len2 &amp;&amp; j&lt;len1; j++)&#123; if( (s1[j]-'0')+(s2[i+j]-'0')&gt;3 )&#123; flag = false; break; &#125; &#125; if(flag)&#123; int now = max(i+len1, len2); if(ans &gt; now)&#123; ans = now; &#125; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; 习题3-12 Floating-Point Numbers UVa1180912 第4章例题部分习题部分]]></content>
      <categories>
        <category>代码题解</category>
      </categories>
      <tags>
        <tag>算法竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日求点到超平面距离]]></title>
    <url>%2F2019%2F08%2F27%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%B1%82%E7%82%B9%E5%88%B0%E8%B6%85%E5%B9%B3%E9%9D%A2%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[文文问怎么推导点到超平面的距离, 除了把它想成Least squares问题外, 这也是一个在给定约束条件下求极值的问题, 顺便测试一下hexo数学符号显示怎么样,新博客的第一篇就写下使用Lagrange multiplier来求这个条件极值问题吧. 先从超平面入手, 超平面的定义是余空间仅为一维的集合, 先设$n$维空间中一点为$\vec x_0=(X_1, X_2,…,X_n)$, 并设超平面的约束条件为$\vec w^T\vec x =b$,其中$\vec w$为$n\times 1$向量.那么我们可以写出Lagrange multiplier:$\mathrm L(\vec x, \lambda)=||\vec x-\vec x_0||^2+\lambda (\vec w^T\vec x-\vec b)$ 求个偏微分: $\frac{\partial L}{\partial \vec x} = 2(\vec x - \vec x_0)+\lambda \vec w =\vec 0$$\frac{\partial L}{\partial \lambda} = \vec w^T\vec x-\vec b=0$ From $\frac{\partial L}{\partial \lambda}$ we obtain:$\vec w^T\vec x-b=0\to\vec w^T\vec x -\vec w^t\vec x_0+\vec w^t\vec x_0-b=0\to \vec w^t(\vec x-\vec x_0)=-\vec w^t\vec x_0+b$将$\frac{\partial L}{\partial \vec x}$左右两边同乘以$\vec w^T:$$2\vec w^T(\vec x - \vec x_0)+\lambda \vec w^T\vec w =\vec 0$然后把刚刚推出来的式子代入$2(\vec w^T\vec x_0-b)=\lambda||\vec w||^2$得出$\lambda=\frac{2(\vec w^T\vec x_0-b)}{||\vec w||^2}$将$\lambda$回代入$\frac{\partial L}{\partial \vec x}$中:$2(\vec x - \vec x_0)+ \frac{2(\vec w^T\vec x_0-b)}{||\vec w||^2}\vec w =\vec 0$得到$(\vec x - \vec x_0)=-\frac{(\vec w^T\vec x_0-b)}{||\vec w||^2}\vec w$ 求个长度便得到距离:$||\vec x - \vec x_0||=|\frac{(\vec w^T\vec x_0-b)}{||\vec w||}|$ 昨天我不知道超平面的定义,导致和文文讲话不在同一个频道. 我以为给定的约束条件中W是个矩阵, 在这个约束条件下$\vec x$的集合就不一定是超平面了. 那么在约束条件$W\vec x=\vec b$下, 问题会是怎样呢? 再废话讲一下前提. 设$n$维空间中一点为$\vec x_0=(X_1, X_2,…,X_n)$, 并设集合$S={\vec x\in \mathbb R^n|W\vec x=\vec b}$约束条件为$W\vec x =\vec b$.其中W为一个$n\times n$的矩阵, $\vec x, \vec b$是$n\times 1$的向量. 那么令$\vec x=(x_1,…,x_n), \vec \lambda=(\lambda_1, …, \lambda_n)$, Lagrange multiplier为: $\mathrm L(\vec x, \vec \lambda)=||\vec x-\vec x_0||^2+\vec \lambda^T(W\vec x-\vec b)$ 求个偏微分:$\frac{\partial L}{\partial \vec x}=2(\vec x-\vec x_0)+W^T\vec \lambda=\vec 0$$\frac{\partial L}{\partial \vec \lambda}=W\vec x-\vec b = \vec 0$ Similarly, from$\frac{\partial L}{\partial \vec \lambda}$we obtain:$W\vec x-W\vec x_0 +W\vec x_0-\vec b=\vec 0\to W(\vec x-\vec x_0)=-W\vec x_0+\vec b$.Both sides of $\frac{\partial L}{\partial \vec x}$ multiply by W:$2W(\vec x-\vec x_0)+WW^T\vec \lambda=\vec 0$Substitute the equation obtained from$\frac{\partial L}{\partial \vec \lambda}$ into $\frac{\partial L}{\partial \vec x}$ we get: $2(W\vec x_0-\vec b)=WW^T\vec \lambda$ Since $WW^T$ is symmetrical, so it’s invertiable. So $\vec \lambda$ is: $\vec \lambda=2(WW^T)^{-1}(W\vec x_0-\vec b)$Substitute $\vec \lambda$ into $\frac{\partial L}{\partial \vec x}$:$2(\vec x-\vec x_0)+2W^T(WW^T)^{-1}(W\vec x_0-\vec b)=\vec 0$Finally we obtain $\vec x-\vec x_0=||W^T(WW^T)^{-1}(W\vec x_0-\vec b)||$ Fuck type too many words.]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>mathematics</tag>
        <tag>Lagrange multiplier</tag>
        <tag>Linear Algbra</tag>
      </tags>
  </entry>
</search>
